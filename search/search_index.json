{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Note rosonic is currently in pre-relase. That means there will be breaking changes as this package grows and becomes better. ROS made pythonic \u00b6 Spend less time working on ROS, spend more time working on Robotics. rosonic is a library that lets you write ROS code with ease and speed. ROS is neither a very good or very bad software system. There are a few problems with ROS and python as is outlined in Motivation . rosonic seeks to solve these by gently \u201cforcing\u201d you to follow a design pattern. Namely, rosonic conceptualizes a ROS node as a class in a simple, pythonic way with reasonable default behaviours. As a consequence rosonic becomes great for both ROS beginners and experienced developers. Quick links \u00b6 Get started Motivation Source code Other resources ROS Wiki ROS Concepts ROS Tutorials rospy","title":"Home"},{"location":"#ros-made-pythonic","text":"Spend less time working on ROS, spend more time working on Robotics. rosonic is a library that lets you write ROS code with ease and speed. ROS is neither a very good or very bad software system. There are a few problems with ROS and python as is outlined in Motivation . rosonic seeks to solve these by gently \u201cforcing\u201d you to follow a design pattern. Namely, rosonic conceptualizes a ROS node as a class in a simple, pythonic way with reasonable default behaviours. As a consequence rosonic becomes great for both ROS beginners and experienced developers.","title":"ROS made pythonic"},{"location":"#quick-links","text":"Get started Motivation Source code Other resources ROS Wiki ROS Concepts ROS Tutorials rospy","title":"Quick links"},{"location":"get-started/","text":"Get started \u00b6 Requirements \u00b6 rosonic has been developed for ROS Melodic and above, i.e Python 2.7, Python 3.6 and above. However, at writing moment only Python 3.6 has been tested. As soon as I\u2019m transitioning my other projects to Noetic then I will drop any support for Python 2.7. Installation \u00b6 This package is available on PyPI and can be installed as a normal pip package. pip install rosonic Usage \u00b6 There will be two nodes for counting numbers in this example. The first simply publishes a uint32 that increases each iteration until it wraps around and starts over. The other node subscribes to the uint32 and publishes a string with binary, and possibly hexadecimal, representation. Let\u2019s start by breaking down the code for the first node. Example 1 \u00b6 #! /usr/bin/env python from rosonic import Node, Parameter from rospy import Publisher from std_msgs.msg import UInt32 class uint_counter(Node): START = Parameter('~start', 0) rate = 4 def __init__(self): self.value = self.START self.pub_counter = Publisher('counter', UInt32, queue_size=1) def spin(self): self.pub_counter.publish(self.value) self.value += 1 self.value %= 32 if __name__ == '__main__': uint_counter(anonymous=True) Example 1 \u2013 Explained \u00b6 We import Node and Parameter from rosonic . You should still import other rospy tools as you need them. There are neither a special Publisher or Subscriber in rosonic yet so we need to use rospy \u2018s for now. from rosonic import Node, Parameter from rospy import Publisher from std_msgs.msg import UInt32 We setup a class to declare the node. The name of the class will be the default name of the node (just as when you call rospy.init_node('<name>') . The special field rate will be turned into a rospy.Rate used to control how often spin will be called. class uint_counter(Node): START = Parameter('~start', 0) rate = 4 One of the benefits of viewing nodes as classes is the clear separation of initialization and the rest of its lifetime. During initialization we want to create resources like publishers, subscribers, services, action-servers and more. It is here we use parameters and setup the runtime behvaiour. In rosonic we naturally utilize the __init__ method with no arguments but self . class uint_counter(Node): ... def __init__(self): self.value = self.START self.pub_counter = Publisher('counter', UInt32, queue_size=1) The innovation of rosonic nodes is very simple, but constitutes of three different methods. __init__ that was previously mentioned, main and spin . In most cases you will not want to change main whose default behaviour will loop over a call spin . spin , on the other hand, is meant to be overloaded. In this example we publish and update the uint32 value. class uint_counter(Node): ... def spin(self): self.pub_counter.publish(self.value) self.value += 1 self.value %= 32 Finally we are ready to start our node! As if it were a normal function we can call uint_counter (with key-word arguments passed to rospy.init_node ) and run the code. This code snippet is required for every rosonic -style node. if __name__ == '__main__': uint_counter(anonymous=True) Example 2 \u00b6 #! /usr/bin/env python from rosonic import Node, Parameter from rospy import Publisher, Subscriber from std_msgs.msg import UInt32, String class str_counter(Node): HEX = Parameter('~hex', False) def __init__(self): self.pub_bin_counter = Publisher( 'bin', String, queue_size=1, ) self.pub_hex_counter = Publisher( 'hex', String, queue_size=1, ) self.sub_uint_counter = Subscriber( 'counter', UInt32, self.uint_counter_cb, ) def uint_counter_cb(self, msg): data = msg.data hex_msg = String('hex=' + hex(data)) bin_msg = String('bin=' + bin(data)) if self.HEX: self.pub_hex_counter.publish(hex_msg) self.pub_bin_counter.publish(bin_msg) if __name__ == '__main__': str_counter(anonymous=True) Example 2 \u2013 Explained \u00b6 Just like in Example 1 we start by declaring a Node class, any parameters and its initialization. Notice that we have a subscriber this time! class str_counter(Node): HEX = Parameter('~hex', False) def __init__(self): self.pub_bin_counter = Publisher( 'bin', String, queue_size=1, ) self.pub_hex_counter = Publisher( 'hex', String, queue_size=1, ) self.sub_uint_counter = Subscriber( 'counter', UInt32, self.uint_counter_cb, ) There is no problem using a method as the callback. Having self in the callback allow us to use resources belonging to the class. It is therefore no need to have any global variables and we can rest assured that data , hex_str and bin_str are all contained in this scope. class str_counter(Node): ... def uint_counter_cb(self, msg): data = msg.data hex_msg = String('hex=' + hex(data)) bin_msg = String('bin=' + bin(data)) if self.HEX: self.pub_hex_counter.publish(hex_msg) self.pub_bin_counter.publish(bin_msg) Then we start the node, just as we did last time! This time we did not overload spin which is also fine. Let\u2019s look at Example 3 to investigate this. if __name__ == '__main__': str_counter(anonymous=True) Example 3 \u00b6 #! /usr/bin/env python from rosonic import Node class dummy(Node): pass if __name__ == '__main__': dummy(anonymous=True) Example 3 \u2013 Explained \u00b6 The purpose of str_counter was to react to uint_counter and only use its one callback. Normally we would call rospy.spin at the end in such nodes. However, this happens automatically in rosonic . Remember __init__ , main and spin ? Well, by default spin calls rospy.spin ! Lets look at the default behaviour of our dummy node. When dummy is called it will (as with any Python class) run __init__ for initialization. This is up to you to decide if it\u2019s necessary or not. if __name__ == '__main__': dummy(anonymous=True) The next step, called internally by rosonic , is main . It will look something like a while-loop that keeps calling spin . The loop is conditioned by keep_alive (that you can also overload if necessary) that by default returns not rospy.is_shutdown() . class Node(...): ... def main(self): while self.keep_alive(): self.spin() self.rate.sleep() self.shutdown() Then there is spin that calls rospy.spin . This essentially means that after __init__ is done, if neither main or spin is overloaded, then the node will fall into rospy.spin until the node is shutdown. class Node(...): ... def spin(self): rospy.spin() What\u2019s next? \u00b6 If you want to learn more about rosonic \u2018s features I recommend you to read the source code. You are also free to contribute with ideas through issue tickets or PR\u2019s.","title":"Get started"},{"location":"get-started/#get-started","text":"","title":"Get started"},{"location":"get-started/#requirements","text":"rosonic has been developed for ROS Melodic and above, i.e Python 2.7, Python 3.6 and above. However, at writing moment only Python 3.6 has been tested. As soon as I\u2019m transitioning my other projects to Noetic then I will drop any support for Python 2.7.","title":"Requirements"},{"location":"get-started/#installation","text":"This package is available on PyPI and can be installed as a normal pip package. pip install rosonic","title":"Installation"},{"location":"get-started/#usage","text":"There will be two nodes for counting numbers in this example. The first simply publishes a uint32 that increases each iteration until it wraps around and starts over. The other node subscribes to the uint32 and publishes a string with binary, and possibly hexadecimal, representation. Let\u2019s start by breaking down the code for the first node.","title":"Usage"},{"location":"get-started/#example-1","text":"#! /usr/bin/env python from rosonic import Node, Parameter from rospy import Publisher from std_msgs.msg import UInt32 class uint_counter(Node): START = Parameter('~start', 0) rate = 4 def __init__(self): self.value = self.START self.pub_counter = Publisher('counter', UInt32, queue_size=1) def spin(self): self.pub_counter.publish(self.value) self.value += 1 self.value %= 32 if __name__ == '__main__': uint_counter(anonymous=True)","title":"Example 1"},{"location":"get-started/#example-1-explained","text":"We import Node and Parameter from rosonic . You should still import other rospy tools as you need them. There are neither a special Publisher or Subscriber in rosonic yet so we need to use rospy \u2018s for now. from rosonic import Node, Parameter from rospy import Publisher from std_msgs.msg import UInt32 We setup a class to declare the node. The name of the class will be the default name of the node (just as when you call rospy.init_node('<name>') . The special field rate will be turned into a rospy.Rate used to control how often spin will be called. class uint_counter(Node): START = Parameter('~start', 0) rate = 4 One of the benefits of viewing nodes as classes is the clear separation of initialization and the rest of its lifetime. During initialization we want to create resources like publishers, subscribers, services, action-servers and more. It is here we use parameters and setup the runtime behvaiour. In rosonic we naturally utilize the __init__ method with no arguments but self . class uint_counter(Node): ... def __init__(self): self.value = self.START self.pub_counter = Publisher('counter', UInt32, queue_size=1) The innovation of rosonic nodes is very simple, but constitutes of three different methods. __init__ that was previously mentioned, main and spin . In most cases you will not want to change main whose default behaviour will loop over a call spin . spin , on the other hand, is meant to be overloaded. In this example we publish and update the uint32 value. class uint_counter(Node): ... def spin(self): self.pub_counter.publish(self.value) self.value += 1 self.value %= 32 Finally we are ready to start our node! As if it were a normal function we can call uint_counter (with key-word arguments passed to rospy.init_node ) and run the code. This code snippet is required for every rosonic -style node. if __name__ == '__main__': uint_counter(anonymous=True)","title":"Example 1 -- Explained"},{"location":"get-started/#example-2","text":"#! /usr/bin/env python from rosonic import Node, Parameter from rospy import Publisher, Subscriber from std_msgs.msg import UInt32, String class str_counter(Node): HEX = Parameter('~hex', False) def __init__(self): self.pub_bin_counter = Publisher( 'bin', String, queue_size=1, ) self.pub_hex_counter = Publisher( 'hex', String, queue_size=1, ) self.sub_uint_counter = Subscriber( 'counter', UInt32, self.uint_counter_cb, ) def uint_counter_cb(self, msg): data = msg.data hex_msg = String('hex=' + hex(data)) bin_msg = String('bin=' + bin(data)) if self.HEX: self.pub_hex_counter.publish(hex_msg) self.pub_bin_counter.publish(bin_msg) if __name__ == '__main__': str_counter(anonymous=True)","title":"Example 2"},{"location":"get-started/#example-2-explained","text":"Just like in Example 1 we start by declaring a Node class, any parameters and its initialization. Notice that we have a subscriber this time! class str_counter(Node): HEX = Parameter('~hex', False) def __init__(self): self.pub_bin_counter = Publisher( 'bin', String, queue_size=1, ) self.pub_hex_counter = Publisher( 'hex', String, queue_size=1, ) self.sub_uint_counter = Subscriber( 'counter', UInt32, self.uint_counter_cb, ) There is no problem using a method as the callback. Having self in the callback allow us to use resources belonging to the class. It is therefore no need to have any global variables and we can rest assured that data , hex_str and bin_str are all contained in this scope. class str_counter(Node): ... def uint_counter_cb(self, msg): data = msg.data hex_msg = String('hex=' + hex(data)) bin_msg = String('bin=' + bin(data)) if self.HEX: self.pub_hex_counter.publish(hex_msg) self.pub_bin_counter.publish(bin_msg) Then we start the node, just as we did last time! This time we did not overload spin which is also fine. Let\u2019s look at Example 3 to investigate this. if __name__ == '__main__': str_counter(anonymous=True)","title":"Example 2 -- Explained"},{"location":"get-started/#example-3","text":"#! /usr/bin/env python from rosonic import Node class dummy(Node): pass if __name__ == '__main__': dummy(anonymous=True)","title":"Example 3"},{"location":"get-started/#example-3-explained","text":"The purpose of str_counter was to react to uint_counter and only use its one callback. Normally we would call rospy.spin at the end in such nodes. However, this happens automatically in rosonic . Remember __init__ , main and spin ? Well, by default spin calls rospy.spin ! Lets look at the default behaviour of our dummy node. When dummy is called it will (as with any Python class) run __init__ for initialization. This is up to you to decide if it\u2019s necessary or not. if __name__ == '__main__': dummy(anonymous=True) The next step, called internally by rosonic , is main . It will look something like a while-loop that keeps calling spin . The loop is conditioned by keep_alive (that you can also overload if necessary) that by default returns not rospy.is_shutdown() . class Node(...): ... def main(self): while self.keep_alive(): self.spin() self.rate.sleep() self.shutdown() Then there is spin that calls rospy.spin . This essentially means that after __init__ is done, if neither main or spin is overloaded, then the node will fall into rospy.spin until the node is shutdown. class Node(...): ... def spin(self): rospy.spin()","title":"Example 3 -- Explained"},{"location":"get-started/#whats-next","text":"If you want to learn more about rosonic \u2018s features I recommend you to read the source code. You are also free to contribute with ideas through issue tickets or PR\u2019s.","title":"What's next?"},{"location":"motivation/","text":"Motivation \u00b6 Following are some problems outlined with ROS and rospy that motivates the use of rosonic . However, no rosonic code will be found here. ROS Nodes \u00b6 When creating a node in ROS, it will typically look something like any of the examples below. #! /usr/bin/env python import rospy ## Publisher pattern ## def main(): # initialization pub = rospy.Publisher(...) rate = rospy.Rate(...) # main loop while not rospy.is_shutdown(): pub.publish(...) rate.sleep() if __name__ == '__main__': rospy.init_node('my_node') try: main() except rospy.ROSInterruptException: pass ## Subscriber pattern ## def callback(msg): ... def main(): # initialization Subscriber(..., callback) # main loop rospy.spin() if __name__ == '__main__': rospy.init_node('my_node') main() ## Pub-Sub pattern ## def callback(msg, args): (pub1, pub2) = args pub1.publish(...) pub2.publish(...) def main(): # initialization pub1 = Publisher(...) pub2 = Publisher(...) Subscriber(..., callback, (pub1, pub2)) # main loop rospy.spin() if __name__ == '__main__': rospy.init_node('my_node') main() Neither of these are very complicated. However, this is mainly since they follow a clear design pattern . When developing, especially in research- oriented projects,following design patterns are often second priority and complexity tend to get out of hand. This is especially true when you start using other ROS concepts more and more. For new users there is also the overhead of learning what a ROS node is, how it behaves and how they relate to other ROS concepts. It may be easy to explain that ROS starts a separate process that runs your python script as a standalone program, the script declares itself to be ROS node with rospy.init_node , opens communication channels for any of your topics, and then it executes your logic. However, that is probably unclear for any developers/researcher that gets thrown into ROS for the first time. As a minor example, how should you design a subscribe-publish node? To clarify, you node should subscribe to some topic, augment the incoming data then, on a new topic, publish it. Should you initialize in main ? How does callback then have your pub ? Maybe you declare pub globally, but that\u2019s a Python anti-pattern! Of course you can solve this neatly and in many ways, but there is nothing in rospy that motivates you to follow best-practice and/or a good design patter. Below is one solution where pub is sent as an argument to callback but you can imagine how that can get out of hand with more publisher and subscribers. The initialization is moved to a dedicated function and, like previously, the node ends on rospy.spin() . #! /usr/bin/env python import rospy def callback(msg, pub): pub.publish(...) def init(): pub = rospy.Publisher(...) rospy.Subscriber(..., callback, pub) if __name__ == '__main__': rospy.init_node('my_node') init() rospy.spin() ROS Parameters \u00b6 Enough about design patterns! I don\u2019t care about writing nice code, why should I care about rosonic ? Now, let me tell you! Surely the most important problems to solve are those that cause mild inconvenience. rosonic will help you once again before you can say \u201cROS parameters\u201d! Let\u2019s look at a typical scenario\u2026 #! /usr/bin/env python import rospy use_filter = True def main(): global use_filter # initialize has_image2 = rospy.has_param('~image2') assert has_image2, 'Parameter \"image2\" is missing!' image1 = rospy.get_param('~image1', 'image1') image2 = rospy.get_param('~image2') use_filter = rospy.get_param('~use_filter', True) pub = rospy.Publisher(image1, ...) Subscriber(image2, ...) # main loop rospy.spin() def callback(msg): if use_filter: ... ... if __name__ == '__main__': main() There are multiple problems with passing topic names through parameters, a very typical use case. Firstly, the distinction between '~image1' and 'image1' is not very clear (a problem not solved by rosonic ). Many times '~image1' may have the default value 'image1' as well! Secondly, asserting that required parameters, such as '~image2' , exists is clunky. Thirdly, parameter values must be passed to different functions/scopes or declared global (same problem as pub before).","title":"Motivation"},{"location":"motivation/#motivation","text":"Following are some problems outlined with ROS and rospy that motivates the use of rosonic . However, no rosonic code will be found here.","title":"Motivation"},{"location":"motivation/#ros-nodes","text":"When creating a node in ROS, it will typically look something like any of the examples below. #! /usr/bin/env python import rospy ## Publisher pattern ## def main(): # initialization pub = rospy.Publisher(...) rate = rospy.Rate(...) # main loop while not rospy.is_shutdown(): pub.publish(...) rate.sleep() if __name__ == '__main__': rospy.init_node('my_node') try: main() except rospy.ROSInterruptException: pass ## Subscriber pattern ## def callback(msg): ... def main(): # initialization Subscriber(..., callback) # main loop rospy.spin() if __name__ == '__main__': rospy.init_node('my_node') main() ## Pub-Sub pattern ## def callback(msg, args): (pub1, pub2) = args pub1.publish(...) pub2.publish(...) def main(): # initialization pub1 = Publisher(...) pub2 = Publisher(...) Subscriber(..., callback, (pub1, pub2)) # main loop rospy.spin() if __name__ == '__main__': rospy.init_node('my_node') main() Neither of these are very complicated. However, this is mainly since they follow a clear design pattern . When developing, especially in research- oriented projects,following design patterns are often second priority and complexity tend to get out of hand. This is especially true when you start using other ROS concepts more and more. For new users there is also the overhead of learning what a ROS node is, how it behaves and how they relate to other ROS concepts. It may be easy to explain that ROS starts a separate process that runs your python script as a standalone program, the script declares itself to be ROS node with rospy.init_node , opens communication channels for any of your topics, and then it executes your logic. However, that is probably unclear for any developers/researcher that gets thrown into ROS for the first time. As a minor example, how should you design a subscribe-publish node? To clarify, you node should subscribe to some topic, augment the incoming data then, on a new topic, publish it. Should you initialize in main ? How does callback then have your pub ? Maybe you declare pub globally, but that\u2019s a Python anti-pattern! Of course you can solve this neatly and in many ways, but there is nothing in rospy that motivates you to follow best-practice and/or a good design patter. Below is one solution where pub is sent as an argument to callback but you can imagine how that can get out of hand with more publisher and subscribers. The initialization is moved to a dedicated function and, like previously, the node ends on rospy.spin() . #! /usr/bin/env python import rospy def callback(msg, pub): pub.publish(...) def init(): pub = rospy.Publisher(...) rospy.Subscriber(..., callback, pub) if __name__ == '__main__': rospy.init_node('my_node') init() rospy.spin()","title":"ROS Nodes"},{"location":"motivation/#ros-parameters","text":"Enough about design patterns! I don\u2019t care about writing nice code, why should I care about rosonic ? Now, let me tell you! Surely the most important problems to solve are those that cause mild inconvenience. rosonic will help you once again before you can say \u201cROS parameters\u201d! Let\u2019s look at a typical scenario\u2026 #! /usr/bin/env python import rospy use_filter = True def main(): global use_filter # initialize has_image2 = rospy.has_param('~image2') assert has_image2, 'Parameter \"image2\" is missing!' image1 = rospy.get_param('~image1', 'image1') image2 = rospy.get_param('~image2') use_filter = rospy.get_param('~use_filter', True) pub = rospy.Publisher(image1, ...) Subscriber(image2, ...) # main loop rospy.spin() def callback(msg): if use_filter: ... ... if __name__ == '__main__': main() There are multiple problems with passing topic names through parameters, a very typical use case. Firstly, the distinction between '~image1' and 'image1' is not very clear (a problem not solved by rosonic ). Many times '~image1' may have the default value 'image1' as well! Secondly, asserting that required parameters, such as '~image2' , exists is clunky. Thirdly, parameter values must be passed to different functions/scopes or declared global (same problem as pub before).","title":"ROS Parameters"}]}